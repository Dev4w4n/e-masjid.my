-- Migration: Add local_admins and user_roles tables
-- Feature: 007-multi-tenant-saas
-- Phase: Foundational (Blocking Prerequisites)
-- Tasks: T011

-- ================================================
-- 1. CREATE LOCAL_ADMINS TABLE
-- ================================================
create table if not exists public.local_admins (
  id uuid primary key default gen_random_uuid(),
  user_id uuid not null references auth.users(id) on delete cascade unique,

  -- Contact details
  full_name text not null,
  whatsapp_number text not null,
  email text not null,

  -- Capacity management
  max_capacity int not null default 10, -- Max Premium masjids assignable
  availability_status text not null default 'available'
    check (availability_status in ('available', 'at-capacity', 'on-leave', 'inactive')),

  -- Earnings tracking
  earnings_summary jsonb,
  -- {
  --   "total_earnings": 1500.00,
  --   "current_month": 450.00,
  --   "pending_transfers": 150.00,
  --   "last_payment_date": "2025-12-24",
  --   "monthly_breakdown": [
  --     { "month": "2025-12", "amount": 450.0 },
  --     { "month": "2025-11", "amount": 600.0 }
  --   ]
  -- }

  -- Audit
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

-- Add indexes for local_admins
create index idx_local_admins_user_id on public.local_admins(user_id);
create index idx_local_admins_availability on public.local_admins(availability_status);

-- Apply updated_at trigger to local_admins
create trigger update_local_admins_updated_at before update on public.local_admins
  for each row execute function public.update_updated_at_column();

-- ================================================
-- 2. ADD FOREIGN KEY TO MASJIDS
-- ================================================
-- Now that local_admins table exists, add the foreign key constraint
alter table public.masjids
  add constraint fk_masjids_local_admin_id
  foreign key (local_admin_id)
  references public.local_admins(id)
  on delete set null;

-- ================================================
-- 3. CREATE LOCAL ADMIN ASSIGNMENTS VIEW
-- ================================================
create or replace view public.local_admin_assignments as
select
  la.id as local_admin_id,
  la.full_name,
  la.max_capacity,
  count(m.id) as assigned_count,
  la.max_capacity - count(m.id) as remaining_capacity
from public.local_admins la
left join public.masjids m on m.local_admin_id = la.id
group by la.id, la.full_name, la.max_capacity;

-- ================================================
-- 4. CREATE USER_ROLE ENUM
-- ================================================
-- Drop old user_role enum from migration 001 (with underscores: super_admin, masjid_admin, etc.)
-- and replace with new enum (with hyphens: super-admin, masjid-admin, etc.)
drop type if exists public.user_role cascade;

create type public.user_role as enum (
  'super-admin',
  'masjid-admin',
  'local-admin',
  'public-user'
);

-- ================================================
-- 5. CREATE USER_ROLES TABLE
-- ================================================
create table if not exists public.user_roles (
  id bigint generated by default as identity primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  role public.user_role not null,
  masjid_id uuid references public.masjids(id) on delete cascade, -- null for super-admin
  created_at timestamptz default now(),
  unique (user_id, role, masjid_id) -- User can have role per masjid
);

-- Add indexes for user_roles
create index idx_user_roles_user_id on public.user_roles(user_id);
create index idx_user_roles_role on public.user_roles(role);
create index idx_user_roles_masjid_id on public.user_roles(masjid_id);

-- ================================================
-- 6. LOCAL ADMIN CAPACITY VALIDATION
-- ================================================
-- Trigger to prevent over-assignment of Local Admins
create or replace function public.check_local_admin_capacity()
returns trigger as $$
declare
  current_count int;
  max_cap int;
begin
  if new.local_admin_id is not null then
    select count(*), la.max_capacity into current_count, max_cap
    from public.masjids m
    join public.local_admins la on la.id = new.local_admin_id
    where m.local_admin_id = new.local_admin_id
    group by la.max_capacity;

    if current_count >= max_cap then
      raise exception 'Local Admin at maximum capacity (%)', max_cap;
    end if;
  end if;

  return new;
end;
$$ language plpgsql;

create trigger check_local_admin_capacity_trigger
  before insert or update on public.masjids
  for each row execute function public.check_local_admin_capacity();

-- ================================================
-- 7. AUTH HOOK FOR JWT INJECTION
-- ================================================
-- Custom access token hook to inject user_role into JWT claims
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb language plpgsql stable as $$
declare
  claims jsonb;
  user_role text;
begin
  -- Fetch highest privilege role
  select role::text into user_role
  from public.user_roles
  where user_id = (event->>'user_id')::uuid
  order by
    case role
      when 'super-admin' then 1
      when 'masjid-admin' then 2
      when 'local-admin' then 3
      else 4
    end
  limit 1;

  claims := event->'claims';

  if user_role is not null then
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));
  else
    claims := jsonb_set(claims, '{user_role}', '"public-user"');
  end if;

  event := jsonb_set(event, '{claims}', claims);
  return event;
end;
$$;

-- Grant permissions for Auth Hook
grant usage on schema public to supabase_auth_admin;
grant execute on function public.custom_access_token_hook to supabase_auth_admin;
grant all on table public.user_roles to supabase_auth_admin;
grant all on table public.masjids to supabase_auth_admin;
revoke execute on function public.custom_access_token_hook from authenticated, anon, public;
